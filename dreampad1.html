<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DreamPad: Freestyle Emotive DAW v1 | Projects by Ash</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            --bg: #101012;
            --panel: #18181b;
            --accent: #dfae68; 
            --secondary: #8a8a9b;
            --kick-row: #2d2018;
            --active-step: #dfae68;
            --muted: #443333;
            --font: 'Segoe UI', monospace;
        }

        body {
            background-color: var(--bg);
            color: var(--secondary);
            font-family: var(--font);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            user-select: none; /* Prevent text selection while jamming */
        }

        /* Header & BPM */
        header {
            width: 100%;
            padding: 15px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            background: #0d0d0f;
            border-bottom: 1px solid #222;
        }

        h1 { margin: 0; color: #fff; font-size: 1.2rem; letter-spacing: 2px; font-weight: 400; }

        .bpm-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--panel);
            padding: 5px 15px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .bpm-input {
            background: transparent;
            border: none;
            color: var(--accent);
            font-family: var(--font);
            font-size: 1.1rem;
            width: 50px;
            text-align: center;
            font-weight: bold;
        }
        .bpm-input:focus { outline: none; border-bottom: 1px solid var(--accent); }

        /* Controls */
        .controls-top {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }

        button {
            background: var(--panel);
            border: 1px solid #333;
            color: #fff;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 4px;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 1px;
            transition: 0.1s;
        }

        button:hover { border-color: var(--accent); }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
        
        button.active-play { background: var(--accent); color: #000; border-color: var(--accent); }
        button.recording { background: #d63031; color: white; border-color: #d63031; }

        /* The Grid */
        .daw-container {
            background: var(--panel);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #222;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        .daw-grid {
            display: grid;
            grid-template-columns: 90px repeat(16, 1fr);
            gap: 3px;
        }

        .track-label {
            display: flex;
            align-items: center;
            font-size: 0.7rem;
            color: #aaa;
            padding-left: 5px;
            font-weight: 600;
        }

        /* Special styling for bottom rows */
        .row-bass .track-label { color: #a8d8ea; }
        .row-kick .track-label { color: #ff9f43; }

        .step {
            width: 28px;
            height: 32px;
            background: #232328;
            border-radius: 2px;
            cursor: pointer;
        }

        .step:hover { background: #333; }
        .step.active { background: var(--active-step); box-shadow: 0 0 8px var(--active-step); }
        
        /* Playhead */
        .step.current { border: 1px solid #fff; }

        /* Kick Mute State */
        .kick-muted .track-label { color: #444; text-decoration: line-through; }
        .kick-muted .step.active { background: #444; box-shadow: none; }

        /* Visualizer & Key Guide */
        .bottom-section {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            width: 100%;
            max-width: 800px;
            align-items: flex-start;
        }

        .visualizer-box {
            flex-grow: 1;
            background: #000;
            height: 100px;
            border-radius: 4px;
            border: 1px solid #333;
            position: relative;
        }
        canvas { width: 100%; height: 100%; opacity: 0.8; }

        .key-guide {
            background: var(--panel);
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #333;
            font-size: 0.75rem;
            min-width: 200px;
        }
        
        .key-guide h3 { margin: 0 0 10px 0; color: #fff; font-size: 0.8rem; }
        .key-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .key { color: var(--accent); font-weight: bold; }

        /* On-screen Slider Feedback */
        .param-display {
            position: absolute;
            top: 10px;
            left: 10px;
            color: var(--accent);
            font-size: 0.8rem;
            pointer-events: none;
        }
    </style>
</head>
<body>

<header>
    <h1>EMOTIVE // ENGINE V2</h1>
    <div class="bpm-container">
        <span>BPM</span>
        <input type="number" id="bpmInput" class="bpm-input" value="122" min="112" max="136">
    </div>
</header>

<div class="controls-top">
    <button id="startBtn">Initialize Audio</button>
    <button id="playBtn" disabled>Play / Pause</button>
    <button id="clearBtn" disabled>Clear Grid</button>
    <button id="recordBtn" disabled>Record .WAV</button>
</div>

<div class="daw-container">
    <div class="daw-grid" id="grid">
        <!-- Generated by JS -->
    </div>
</div>

<div class="bottom-section">
    <div class="key-guide">
        <h3>LIVE PERFORMANCE KEYS</h3>
        <div class="key-row"><span>Filter Cutoff</span> <span class="key">W / S</span></div>
        <div class="key-row"><span>Reverb</span> <span class="key">↑ / ↓</span></div>
        <div class="key-row"><span>Delay</span> <span class="key">← / →</span></div>
        <div class="key-row"><span>Panning</span> <span class="key">O / P</span></div>
        <div class="key-row"><span>Kick Cut (Kill)</span> <span class="key">K</span></div>
    </div>
    <div class="visualizer-box">
        <div class="param-display" id="paramDisplay">Ready.</div>
        <canvas id="visualizer"></canvas>
    </div>
</div>

<script>
    // --- CONFIGURATION ---
    const STEPS = 16;
    // C Minor Scale for Melodic Elements
    const SCALE_BASS = ['C2', 'Eb2', 'F2', 'G2', 'Bb2'];
    const SCALE_PADS = ['C3', 'Eb3', 'G3', 'Bb3', 'C4']; 
    const SCALE_PLUCK = ['Eb4', 'F4', 'G4', 'Bb4', 'C5'];
    const SCALE_GLITTER = ['G5', 'Bb5', 'C6', 'Eb6', 'G6'];

    let isPlaying = false;
    let currentStep = 0;
    let recorder, recordingChunks = [];
    let kickMuted = false;

    // TRACKS ARRANGEMENT (High Freq -> Low Freq)
    const tracks = [
        { name: "GLITTER", type: "melodic", scale: SCALE_GLITTER, id: 'glitter' },
        { name: "HATS", type: "rhythm", id: 'hat' },
        { name: "PLUCK", type: "melodic", scale: SCALE_PLUCK, id: 'pluck' },
        { name: "TENSION", type: "noise", id: 'tension' }, // New: White noise swells
        { name: "CLAP", type: "rhythm", id: 'clap' },
        { name: "DRONE", type: "drone", scale: SCALE_PADS, id: 'drone' }, // New: Cinematic background
        { name: "PADS", type: "melodic", scale: SCALE_PADS, id: 'pad' },
        { name: "BASS", type: "melodic", scale: SCALE_BASS, id: 'bass', css: 'row-bass' },
        { name: "KICK", type: "rhythm", id: 'kick', css: 'row-kick' }
    ];

    // Initialize Grid
    const gridEl = document.getElementById('grid');
    const matrix = [];

    tracks.forEach((track, tIndex) => {
        const rowClass = track.css || '';
        const label = document.createElement('div');
        label.className = `track-label ${rowClass}`;
        label.innerText = track.name;
        label.id = `label-${tIndex}`;
        gridEl.appendChild(label);

        matrix[tIndex] = [];
        for (let i = 0; i < STEPS; i++) {
            const step = document.createElement('div');
            step.className = `step ${rowClass}`;
            step.dataset.track = tIndex;
            step.dataset.step = i;

            // Default Pattern Logic
            let active = false;
            if (track.name === "KICK" && i % 4 === 0) active = true;
            if (track.name === "HATS" && i % 2 !== 0) active = true;
            
            if (active) {
                step.classList.add('active');
                matrix[tIndex][i] = true;
            } else {
                matrix[tIndex][i] = false;
            }

            step.addEventListener('click', () => {
                step.classList.toggle('active');
                matrix[tIndex][i] = !matrix[tIndex][i];
            });
            gridEl.appendChild(step);
        }
    });

    // --- AUDIO ENGINE ---
    let instruments = {};
    let masterFilter, masterReverb, masterDelay, masterComp, masterPanner;
    let analyser;
    
    // Parameter State
    let params = {
        cutoff: 800,
        reverb: 0.3,
        delay: 0.2,
        pan: 0
    };

    async function initAudio() {
        await Tone.start();

        // 1. Master Chain
        masterPanner = new Tone.Panner(0).toDestination();
        
        masterReverb = new Tone.Reverb({ decay: 5, preDelay: 0.2, wet: params.reverb }).connect(masterPanner);
        
        masterDelay = new Tone.PingPongDelay({
            delayTime: "8n.", feedback: 0.3, wet: params.delay
        }).connect(masterReverb);

        masterFilter = new Tone.Filter(params.cutoff, "lowpass", -24).connect(masterDelay);
        
        masterComp = new Tone.Compressor({
            threshold: -18, ratio: 4, attack: 0.05, release: 0.2
        }).connect(masterFilter);
        
        // Route dry signal partially to comp as well for parallel processing feel
        // But for simplicity, we route everything through Comp -> Filter -> FX

        // 2. Instruments Setup
        
        // KICK
        instruments.kick = new Tone.MembraneSynth({
            pitchDecay: 0.05, octaves: 6, oscillator: { type: "sine" },
            envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
        }).connect(masterComp);

        // HATS
        instruments.hat = new Tone.MetalSynth({
            frequency: 200, envelope: { attack: 0.001, decay: 0.05, release: 0.01 },
            harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
        }).connect(masterComp);
        instruments.hat.volume.value = -14;

        // CLAP
        instruments.clap = new Tone.NoiseSynth({
            noise: { type: 'pink' }, envelope: { attack: 0.001, decay: 0.15, sustain: 0 }
        }).connect(masterReverb); // Claps go to reverb
        instruments.clap.volume.value = -10;

        // BASS
        instruments.bass = new Tone.FMSynth({
            harmonicity: 1, modulationIndex: 10, detune: 0, oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.4, release: 0.5 },
            modulation: { type: "square" }, modulationEnvelope: { attack: 0.05, decay: 0.01, sustain: 1, release: 0.5 }
        }).connect(masterFilter);
        instruments.bass.volume.value = -4;

        // PADS
        instruments.pad = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "fatsawtooth", count: 3, spread: 20 },
            envelope: { attack: 0.4, decay: 1, sustain: 0.6, release: 2 }
        }).connect(masterFilter);
        instruments.pad.volume.value = -15;

        // PLUCK
        instruments.pluck = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "triangle" },
            envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 1 }
        }).connect(masterDelay);
        instruments.pluck.volume.value = -10;

        // GLITTER (New)
        instruments.glitter = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 1.5 }
        }).connect(masterDelay);
        instruments.glitter.volume.value = -12;

        // TENSION (New) - Filtered Noise hits
        instruments.tension = new Tone.NoiseSynth({
            noise: { type: 'white' },
            envelope: { attack: 0.5, decay: 0.5, sustain: 0, release: 0.5 }
        }).connect(masterReverb);
        instruments.tension.volume.value = -18;

        // DRONE (New)
        instruments.drone = new Tone.PolySynth(Tone.FMSynth, {
            harmonicity: 0.5, modulationIndex: 2,
            envelope: { attack: 2, decay: 1, sustain: 1, release: 3 }
        }).connect(masterFilter);
        instruments.drone.volume.value = -20;

        // 3. Transport
        Tone.Transport.scheduleRepeat(onStep, "16n");
        const bpmVal = document.getElementById('bpmInput').value;
        Tone.Transport.bpm.value = bpmVal;

        // 4. Recorder
        const dest = Tone.context.createMediaStreamDestination();
        masterPanner.connect(dest);
        recorder = new MediaRecorder(dest.stream);
        recorder.ondataavailable = e => recordingChunks.push(e.data);
        recorder.onstop = saveRecording;

        // 5. Visualizer
        analyser = new Tone.Analyser("waveform", 256);
        masterPanner.connect(analyser);
        drawVisualizer();

        // UI Logic
        document.getElementById('startBtn').style.display = 'none';
        document.getElementById('playBtn').disabled = false;
        document.getElementById('clearBtn').disabled = false;
        document.getElementById('recordBtn').disabled = false;
        
        setupKeyboardControls();
    }

    function onStep(time) {
        // UI Step Update
        const steps = document.querySelectorAll('.step');
        steps.forEach(s => s.classList.remove('current'));
        
        for (let t = 0; t < tracks.length; t++) {
            const stepEl = document.querySelector(`.step[data-track="${t}"][data-step="${currentStep}"]`);
            if(stepEl) stepEl.classList.add('current');

            if (matrix[t][currentStep]) {
                const tr = tracks[t];
                const inst = instruments[tr.id];

                // Kick Mute Logic
                if (tr.name === "KICK" && kickMuted) continue;

                if (tr.type === "rhythm") {
                    if (tr.name === "KICK") inst.triggerAttackRelease("C1", "8n", time);
                    else if (tr.name === "HATS") inst.triggerAttackRelease("32n", time, 0.5 + Math.random()*0.3);
                    else if (tr.name === "CLAP") inst.triggerAttackRelease("16n", time);
                } 
                else if (tr.type === "noise") {
                    inst.triggerAttackRelease("8n", time);
                }
                else if (tr.type === "melodic" || tr.type === "drone") {
                    // Step-based Arp/Chord generation
                    const scaleLen = tr.scale.length;
                    const n1 = tr.scale[currentStep % scaleLen];
                    
                    if (tr.name === "PADS" || tr.name === "DRONE") {
                        // Play dyads (2 notes)
                        const n2 = tr.scale[(currentStep + 2) % scaleLen];
                        inst.triggerAttackRelease([n1, n2], "2n", time);
                    } else {
                        // Single notes
                        inst.triggerAttackRelease(n1, "16n", time);
                    }
                }
            }
        }
        currentStep = (currentStep + 1) % STEPS;
    }

    // --- CONTROLS ---

    document.getElementById('startBtn').addEventListener('click', initAudio);
    
    document.getElementById('playBtn').addEventListener('click', () => {
        if (!isPlaying) {
            Tone.Transport.start();
            document.getElementById('playBtn').innerText = "STOP";
            document.getElementById('playBtn').classList.add('active-play');
        } else {
            Tone.Transport.stop();
            document.getElementById('playBtn').innerText = "PLAY / PAUSE";
            document.getElementById('playBtn').classList.remove('active-play');
            currentStep = 0;
        }
        isPlaying = !isPlaying;
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
        matrix.forEach(row => row.fill(false));
        document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
    });

    document.getElementById('recordBtn').addEventListener('click', () => {
        if (recorder.state === "inactive") {
            recordingChunks = [];
            recorder.start();
            document.getElementById('recordBtn').innerText = "STOP REC";
            document.getElementById('recordBtn').classList.add('recording');
        } else {
            recorder.stop();
            document.getElementById('recordBtn').innerText = "RECORD .WAV";
            document.getElementById('recordBtn').classList.remove('recording');
        }
    });

    document.getElementById('bpmInput').addEventListener('change', (e) => {
        let val = parseInt(e.target.value);
        if(val < 112) val = 112;
        if(val > 136) val = 136;
        e.target.value = val;
        Tone.Transport.bpm.rampTo(val, 0.1);
    });

    function saveRecording() {
        const blob = new Blob(recordingChunks, { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = `session-${Date.now()}.wav`;
        document.body.appendChild(a);
        a.click();
    }

    // --- KEYBOARD / GAME CONTROLS ---
    function updateDisplay(text) {
        const el = document.getElementById('paramDisplay');
        el.innerText = text;
        el.style.opacity = 1;
        clearTimeout(el.timeout);
        el.timeout = setTimeout(() => el.style.opacity = 0.5, 1000);
    }

    function setupKeyboardControls() {
        document.addEventListener('keydown', (e) => {
            if (!isPlaying && e.key !== ' ' && e.key !== 'Enter') return;

            const step = 0.05;
            const freqStep = 200;

            // FILTER (W/S)
            if (e.key.toLowerCase() === 'w') {
                params.cutoff = Math.min(params.cutoff + freqStep, 8000);
                masterFilter.frequency.rampTo(params.cutoff, 0.1);
                updateDisplay(`Filter: ${Math.round(params.cutoff)}Hz`);
            }
            if (e.key.toLowerCase() === 's') {
                params.cutoff = Math.max(params.cutoff - freqStep, 100);
                masterFilter.frequency.rampTo(params.cutoff, 0.1);
                updateDisplay(`Filter: ${Math.round(params.cutoff)}Hz`);
            }

            // REVERB (Arrow Up/Down)
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                params.reverb = Math.min(params.reverb + step, 1);
                masterReverb.wet.rampTo(params.reverb, 0.1);
                updateDisplay(`Reverb: ${Math.round(params.reverb * 100)}%`);
            }
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                params.reverb = Math.max(params.reverb - step, 0);
                masterReverb.wet.rampTo(params.reverb, 0.1);
                updateDisplay(`Reverb: ${Math.round(params.reverb * 100)}%`);
            }

            // DELAY (Arrow Left/Right)
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                params.delay = Math.min(params.delay + step, 1);
                masterDelay.wet.rampTo(params.delay, 0.1);
                updateDisplay(`Delay: ${Math.round(params.delay * 100)}%`);
            }
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                params.delay = Math.max(params.delay - step, 0);
                masterDelay.wet.rampTo(params.delay, 0.1);
                updateDisplay(`Delay: ${Math.round(params.delay * 100)}%`);
            }

            // PAN (O/P)
            if (e.key.toLowerCase() === 'o') {
                params.pan = Math.max(params.pan - 0.1, -1);
                masterPanner.pan.rampTo(params.pan, 0.1);
                updateDisplay(`Pan: L ${Math.round(params.pan * -100)}`);
            }
            if (e.key.toLowerCase() === 'p') {
                params.pan = Math.min(params.pan + 0.1, 1);
                masterPanner.pan.rampTo(params.pan, 0.1);
                updateDisplay(`Pan: R ${Math.round(params.pan * 100)}`);
            }

            // KICK KILL SWITCH (K)
            if (e.key.toLowerCase() === 'k') {
                kickMuted = !kickMuted;
                const kickRow = document.querySelector('.row-kick'); // Select based on class added
                const label = document.getElementById('label-8'); // Kick is last index
                
                if(kickMuted) {
                    updateDisplay("KICK MUTED");
                    if(kickRow) kickRow.classList.add('kick-muted');
                    // Also add class to label parent if needed, or handle via CSS selector
                    // Since tracks are generated, we find the specific kick row elements
                    document.querySelectorAll('.step[data-track="8"]').forEach(el => el.parentElement.classList.add('kick-muted'));
                } else {
                    updateDisplay("KICK ACTIVE");
                    document.querySelectorAll('.step[data-track="8"]').forEach(el => el.parentElement.classList.remove('kick-muted'));
                }
            }
        });
    }

    // --- VISUALIZER LOOP ---
    const canvas = document.getElementById("visualizer");
    const ctx = canvas.getContext("2d");
    
    function drawVisualizer() {
        requestAnimationFrame(drawVisualizer);
        if(!analyser) return;
        
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = analyser.getValue();
        
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#dfae68";
        ctx.beginPath();

        const sliceWidth = canvas.width / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
            const v = (dataArray[i] + 1) / 2; 
            const y = v * canvas.height;

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);

            x += sliceWidth;
        }

        ctx.lineTo(canvas.width, canvas.height / 2);
        ctx.stroke();
    }
</script>
</body>
</html>